<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Bubble Pop Game (Web)</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load MediaPipe Hands for gesture tracking -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <!-- Load Matter.js for physics simulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* Ensure the body takes full viewport height for centering */
        body {
            height: 100vh;
            background-color: #1a202c; /* Dark background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', sans-serif;
        }
        /* Style the canvas to ensure it is visible and centered */
        #game-canvas {
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            /* Remove background-color here so the video drawn underneath is visible */
            background-color: transparent; 
            position: relative; /* Needed for overlay positioning */
        }
        /* Style for the start button */
        #start-button {
            padding: 1rem 2.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: transform 0.1s;
        }
        #start-button:hover {
            transform: scale(1.05);
        }

        /* NEW: Game Overlay Styling */
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
            justify-content: center; /* Center items vertically */
            pointer-events: none; /* Allows clicks to pass through to the canvas/start button */
            z-index: 10;
        }

    </style>
</head>
<body class="p-4">

    <div class="max-w-4xl w-full text-white text-center">
        <h1 class="text-4xl font-extrabold mb-2 text-teal-400">Gesture Bubble Pop (Web)</h1>
        <p class="text-sm mb-6 text-gray-400" id="status-message">
            Loading MediaPipe and Physics Engine...
        </p>

        <!-- Display Score and Instructions -->
        <div class="flex justify-between items-center mb-4 p-3 bg-gray-700 rounded-lg shadow-lg">
            <div id="score-display" class="text-3xl font-bold text-yellow-300">Score: 0</div>
            <!-- NEW MISSED COUNT DISPLAY -->
            <div id="missed-display" class="text-2xl font-semibold text-red-400">Missed: 0 / 3</div>
            <div class="text-left text-sm text-gray-300">
                <p>ðŸ‘Š **POP:** Closed fist + Index finger near bubble.</p>
                <p>âœ‹ **PUSH:** Open palm to move bubbles.</p>
            </div>
        </div>
        
        <!-- Video element for camera feed (hidden from display, but stream is accessible) -->
        <video id="webcam" autoplay playsinline style="display: none;"></video>
        
        <!-- Canvas Container -->
        <div class="relative inline-block">
            <!-- Canvas for rendering the game overlay -->
            <canvas id="game-canvas" width="1024" height="576"></canvas>

            <!-- Overlay for Start/Game Over screen -->
            <div id="game-overlay">
                <!-- Start Button Overlay -->
                <button id="start-button" class="bg-green-500 hover:bg-green-600 text-white" style="display:none; pointer-events: auto;">Start Game</button>
            </div>
        </div>
        
    </div>

    <script>
        // --- Global Config ---
        const CANVAS_WIDTH = 1024;
        const CANVAS_HEIGHT = 576;
        let SPAWN_INTERVAL = 1500; // ms (Initial interval: 1.5 seconds)
        const MIN_SPAWN_INTERVAL = 500; // ms (Fastest possible interval)
        const DIFFICULTY_REDUCTION = 100; // ms to reduce interval by per step
        const DIFFICULTY_STEP_TIME = 10000; // 10 seconds
        const BUBBLE_RADIUS_MIN = 20;
        const BUBBLE_RADIUS_MAX = 40;
        const POP_DISTANCE_THRESHOLD = 30; // Max distance in pixels to pop
        const FPS = 60;

        // --- Game State ---
        let score = 0;
        let bubbles = [];
        let handLandmarks = null;
        let isCameraActive = false;
        
        // NEW GAME START FLAG
        let isGameStarted = false; 

        // NEW DIFFICULTY AND GAME OVER STATE
        let missedBubblesCount = 0;
        const maxMissedBubbles = 3;
        let isGameOver = false;
        let spawnIntervalId = null;
        let startTime = null; // To track game duration
        
        // Difficulty tracking
        let lastDifficultyIncreaseTime = null; 
        
        // --- DOM Elements ---
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('game-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const statusMessage = document.getElementById('status-message');
        const missedDisplay = document.getElementById('missed-display'); // New DOM element
        const startButton = document.getElementById('start-button');
        const gameOverlay = document.getElementById('game-overlay');

        // --- Physics Engine (Matter.js) Setup ---
        const Engine = Matter.Engine,
              Events = Matter.Events, // Import Events
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Vector = Matter.Vector;

        const engine = Engine.create();
        const world = engine.world;
        // Set gravity to negative so bubbles float upwards toward the miss zone (top)
        engine.gravity.y = -0.05; 
        
        // Add boundaries (Ground and Walls)
        const thickness = 30; 
        
        // Define bodies outside the array for access in event listeners
        const floor = Bodies.rectangle(CANVAS_WIDTH / 2, CANVAS_HEIGHT - thickness / 2, CANVAS_WIDTH, thickness, { 
            isStatic: true, 
            label: 'Floor', 
            id: 'floor', // Add unique ID for collision detection
            render: { fillStyle: '#4a5568' } // Gray floor boundary
        });
        const ceiling = Bodies.rectangle(CANVAS_WIDTH / 2, thickness / 2, CANVAS_WIDTH, thickness, { 
            isStatic: true, 
            label: 'Ceiling', 
            id: 'ceiling', // Add unique ID for collision detection
            render: { fillStyle: '#ff0000' } // Red miss zone
        });
        
        const walls = [
            floor,
            ceiling,
            // Walls
            Bodies.rectangle(thickness / 2, CANVAS_HEIGHT / 2, thickness, CANVAS_HEIGHT, { isStatic: true, label: 'Wall' }),
            Bodies.rectangle(CANVAS_WIDTH - thickness / 2, CANVAS_HEIGHT / 2, thickness, CANVAS_HEIGHT, { isStatic: true, label: 'Wall' }),
        ];
        Composite.add(world, walls);
        
        // --- Matter.js Collision Handling ---
        Events.on(engine, 'collisionStart', (event) => {
            if (isGameOver) return;

            const pairs = event.pairs;
            
            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                let bubbleBody = null;
                // We only care about the ceiling boundary collision (miss zone)
                if (bodyA.label === 'Bubble' && bodyB.id === 'ceiling') {
                    bubbleBody = bodyA;
                } else if (bodyB.label === 'Bubble' && bodyA.id === 'ceiling') {
                    bubbleBody = bodyB;
                }

                // If a bubble hits the ceiling/miss zone, count it as a miss and pop it
                if (bubbleBody) {
                    missedBubblesCount++;
                    missedDisplay.textContent = `Missed: ${missedBubblesCount} / ${maxMissedBubbles}`;
                    removeBubble(bubbleBody); // Remove it immediately to prevent stacking

                    if (missedBubblesCount >= maxMissedBubbles) {
                        gameOver();
                    }
                }
            });
        });


        // --- MediaPipe Hands Setup ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        function onResults(results) {
            // Store normalized landmarks globally
            handLandmarks = results.multiHandHandLandmarks;
        }
        
        function gameOver() {
            isGameOver = true;
            clearInterval(spawnIntervalId);
            
            // Draw Game Over Text
            canvasCtx.font = "bold 60px Inter";
            canvasCtx.fillStyle = 'rgba(255, 50, 50, 0.9)';
            canvasCtx.textAlign = 'center';
            canvasCtx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            canvasCtx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 70);
            
            // Display Retry Button
            startButton.textContent = "RETRY";
            startButton.onclick = () => window.location.reload(); // Simple retry function
            startButton.style.display = 'block';
            startButton.style.position = 'relative'; // Ensure button is centered within the overlay div
            
            gameOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)'; // Apply dark overlay
            gameOverlay.style.pointerEvents = 'auto';
            statusMessage.textContent = "GAME OVER! Three bubbles missed. Click RETRY to play again.";
        }

        function createBubble() {
            const radius = Math.random() * (BUBBLE_RADIUS_MAX - BUBBLE_RADIUS_MIN) + BUBBLE_RADIUS_MIN;
            // Spawn point at the bottom of the screen (high Y in Matter.js world)
            const x = CANVAS_WIDTH * (0.2 + Math.random() * 0.6);
            const y = CANVAS_HEIGHT - radius - 5; 
            
            const bubble = Bodies.circle(x, y, radius, {
                restitution: 0.9,
                friction: 0.001,
                density: 0.0001, 
                label: 'Bubble',
                plugin: { 
                    bubble: true, 
                    radius: radius 
                }
            });

            Composite.add(world, bubble);
            bubbles.push(bubble);
        }

        function removeBubble(bubble) {
            Composite.remove(world, bubble);
            bubbles = bubbles.filter(b => b.id !== bubble.id);
        }

        function popBubbleCheck(handLandmarks) {
            if (!handLandmarks) return;

            handLandmarks.forEach(landmarks => {
                // MediaPipe gives normalized (0 to 1) coordinates.
                if (!landmarks) return;

                // --- MIRRORING FIX: Apply 1 - X transformation ---
                const standardTipX = landmarks[8].x;
                const tipX = CANVAS_WIDTH * (1 - standardTipX); // Mirrored X
                const tipY = landmarks[8].y * CANVAS_HEIGHT;

                // Check for POP Gesture: Index Tip (8) is *above* Index MCP (5)
                const isPopGesture = landmarks[8].y < landmarks[5].y;

                // Check for Closed Fist: Middle finger tip (12) is below middle finger MCP (9)
                const isClosed = landmarks[12].y > landmarks[9].y && landmarks[16].y > landmarks[13].y;
                
                if (isPopGesture && isClosed) {
                    // Draw Red Circle for Pop Gesture
                    canvasCtx.beginPath();
                    canvasCtx.arc(tipX, tipY, 15, 0, 2 * Math.PI);
                    canvasCtx.strokeStyle = 'red';
                    canvasCtx.lineWidth = 3;
                    canvasCtx.stroke();

                    // Check for bubble contact
                    bubbles.forEach(bubble => {
                        // Matter.js Y is inverted for drawing (Y=0 is top in physics, Y=0 is top in canvas)
                        const bubbleX = bubble.position.x;
                        const bubbleY = CANVAS_HEIGHT - bubble.position.y;
                        const radius = bubble.plugin.radius;

                        const distance = Math.hypot(tipX - bubbleX, tipY - bubbleY);

                        if (distance < radius + POP_DISTANCE_THRESHOLD) {
                            score++;
                            scoreDisplay.textContent = `Score: ${score}`;
                            removeBubble(bubble);
                        }
                    });
                } 
                
                // --- Gesture: PUSH/MOVE (Open Palm) ---
                else if (landmarks[12].y < landmarks[9].y) { // Simple check for open hand
                    // --- MIRRORING FIX: Apply 1 - X transformation ---
                    const standardPalmX = landmarks[0].x;
                    const palmX = CANVAS_WIDTH * (1 - standardPalmX); // Mirrored X
                    const palmY = landmarks[0].y * CANVAS_HEIGHT;

                    // Draw Yellow Circle for Push Gesture
                    canvasCtx.beginPath();
                    canvasCtx.arc(palmX, palmY, 20, 0, 2 * Math.PI);
                    canvasCtx.strokeStyle = 'yellow';
                    canvasCtx.lineWidth = 3;
                    canvasCtx.stroke();

                    // Apply force to bubbles near the palm
                    bubbles.forEach(bubble => {
                        const bubblePos = { x: bubble.position.x, y: CANVAS_HEIGHT - bubble.position.y };
                        const palmPos = { x: palmX, y: palmY };
                        const radius = bubble.plugin.radius;

                        const distance = Math.hypot(palmPos.x - bubblePos.x, palmPos.y - bubblePos.y);

                        if (distance < radius + 50) {
                            // Calculate simple push force away from the palm
                            const dx = bubblePos.x - palmPos.x;
                            const dy = bubblePos.y - palmPos.y;
                            
                            // Matter.js force vector must be in the physics coordinate system (Y inverted)
                            const force = Vector.mult({ x: dx, y: -dy }, 0.00005); 
                            Matter.Body.applyForce(bubble, bubble.position, force);
                        }
                    });
                }
            });
        }
        
        function drawStartScreen() {
            // Draw video feed and overlay instructions
            canvasCtx.save();
            canvasCtx.scale(-1, 1);
            canvasCtx.translate(-CANVAS_WIDTH, 0); 
            canvasCtx.drawImage(videoElement, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            canvasCtx.restore(); 
            
            // Dark overlay for readability
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            canvasCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            canvasCtx.fillStyle = 'white';
            canvasCtx.textAlign = 'center';
            canvasCtx.font = "bold 48px Inter";
            canvasCtx.fillText("Welcome to Bubble Pop!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 4);

            canvasCtx.font = "24px Inter";
            canvasCtx.fillText("Get ready to pop the floating bubbles with your hand gestures.", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 4 + 50);

            // Instructions text
            canvasCtx.textAlign = 'left';
            canvasCtx.font = "20px Inter";
            let lineY = CANVAS_HEIGHT / 2 - 30;
            const lineSpacing = 30;

            canvasCtx.fillStyle = '#6EE7B7'; // Teal
            canvasCtx.fillText("Phase 1: Easy Start (Difficulty increases every 10 seconds)", 200, lineY);
            lineY += lineSpacing;

            canvasCtx.fillStyle = 'white';
            canvasCtx.fillText("1. POP: Use a closed fist with an extended index finger.", 200, lineY);
            lineY += lineSpacing;
            canvasCtx.fillText("2. PUSH: Use an open palm to nudge bubbles away from the ceiling (red zone).", 200, lineY);
            lineY += lineSpacing;
            canvasCtx.fillText("3. Game Over: Miss 3 bubbles (let them touch the ceiling).", 200, lineY);
            lineY += lineSpacing * 2;
            
            canvasCtx.fillStyle = '#FBBF24'; // Yellow
            canvasCtx.fillText("Click START when you are ready!", CANVAS_WIDTH / 2, lineY);

            // Display Start Button via the overlay div
            startButton.textContent = "START GAME";
            startButton.style.display = 'block';
            gameOverlay.style.pointerEvents = 'auto'; // Re-enable pointer events for the button
            
            // --- FIX: Aligning the button in the center of the overlay ---
            gameOverlay.style.justifyContent = 'flex-end'; // Push button to the bottom
            gameOverlay.style.paddingBottom = '80px'; // Add some padding from the bottom
            // The button itself is centered horizontally because the game-overlay uses align-items: center

            // Check if MediaPipe is actively tracking hands
            if (handLandmarks) {
                popBubbleCheck(handLandmarks);
            }
        }


        // --- Rendering Loop ---

        function drawGame() {
            
            // If the game hasn't started, draw the instruction screen
            if (!isGameStarted) {
                if (isCameraActive) {
                    drawStartScreen();
                }
                // Continue feeding MediaPipe even on start screen
                requestAnimationFrame(drawGame);
                return; 
            }
            
            // NEW: Check Game Over State
            if (isGameOver) {
                gameOver(); // Redraws the Game Over screen
                // Continue MediaPipe loop but pause Matter.js updates
                Engine.update(engine, 1000 / FPS); 
                requestAnimationFrame(drawGame);
                return;
            }

            // --- DIFFICULTY CHECK (Every 10 seconds) ---
            const currentTime = Date.now();
            if (lastDifficultyIncreaseTime && currentTime - lastDifficultyIncreaseTime > DIFFICULTY_STEP_TIME) {
                // Increase difficulty only if we haven't hit the minimum interval
                if (SPAWN_INTERVAL > MIN_SPAWN_INTERVAL) {
                    SPAWN_INTERVAL = Math.max(MIN_SPAWN_INTERVAL, SPAWN_INTERVAL - DIFFICULTY_REDUCTION); // Reduce interval
                    
                    // Restart interval with the new, faster rate
                    clearInterval(spawnIntervalId);
                    spawnIntervalId = setInterval(createBubble, SPAWN_INTERVAL);
                    
                    lastDifficultyIncreaseTime = currentTime; // Reset the timer for the next step
                    
                    // Update Status Message
                    statusMessage.textContent = `DIFFICULTY STEP UP! Spawn Rate: ${SPAWN_INTERVAL}ms`;
                }
            }
            
            // 1. Draw the live video feed as the background (Mirrored for user experience)
            canvasCtx.save();
            canvasCtx.scale(-1, 1);
            // Translate origin to the right side of the canvas before drawing the flipped image
            canvasCtx.translate(-CANVAS_WIDTH, 0); 
            canvasCtx.drawImage(videoElement, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            canvasCtx.restore(); // Restore context state

            // 2. Draw Bubbles
            canvasCtx.fillStyle = 'rgba(100, 255, 255, 0.5)'; // Light blue translucent
            canvasCtx.strokeStyle = 'rgba(100, 255, 255, 1)';
            canvasCtx.lineWidth = 2;
            
            // Iterate backwards to safely remove elements
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const bubble = bubbles[i];
                const x = bubble.position.x;
                // Convert Matter.js Y (bottom-up) to Canvas Y (top-down)
                const y = CANVAS_HEIGHT - bubble.position.y; 
                const radius = bubble.plugin.radius;

                canvasCtx.beginPath();
                canvasCtx.arc(x, y, radius, 0, 2 * Math.PI);
                canvasCtx.fill();
                canvasCtx.stroke();
            }
            
            // 3. Draw Hand Gestures and Check for Pops
            popBubbleCheck(handLandmarks);

            // Draw boundaries 
            
            // Draw the ground/floor zone (bottom) in GRAY
            canvasCtx.fillStyle = '#4a5568';
            canvasCtx.fillRect(0, CANVAS_HEIGHT - thickness, CANVAS_WIDTH, thickness);

            // Draw the ceiling/miss zone (top) in RED 
            canvasCtx.fillStyle = 'rgba(255, 0, 0, 0.5)'; 
            canvasCtx.fillRect(0, 0, CANVAS_WIDTH, thickness); 

            // 4. Update Physics Engine
            Engine.update(engine, 1000 / FPS); 

            // 5. Request next frame
            requestAnimationFrame(drawGame);
        }

        // --- Initialization and Camera ---
        
        function startGame() {
            // Hide overlay elements
            startButton.style.display = 'none';
            gameOverlay.style.pointerEvents = 'none';
            gameOverlay.style.backgroundColor = 'transparent';
            
            // Reset overlay alignment for game use
            gameOverlay.style.justifyContent = 'center';
            gameOverlay.style.paddingBottom = '0px';


            // Clear any existing bubbles from the start screen
            bubbles.forEach(bubble => Composite.remove(world, bubble));
            bubbles = [];

            // Reset scores and state
            score = 0;
            missedBubblesCount = 0;
            isGameOver = false;
            SPAWN_INTERVAL = 1500; // Reset to initial slow rate
            scoreDisplay.textContent = `Score: 0`;
            missedDisplay.textContent = `Missed: 0 / ${maxMissedBubbles}`;
            statusMessage.textContent = "Camera active. Running gesture detection...";
            
            // Start physics and game loops
            startTime = Date.now();
            lastDifficultyIncreaseTime = Date.now(); // Start timer now
            spawnIntervalId = setInterval(createBubble, SPAWN_INTERVAL);
            isGameStarted = true;
        }

        async function startCamera() {
            statusMessage.textContent = "Requesting camera permission...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    'video': {
                        facingMode: 'user',
                        width: { ideal: CANVAS_WIDTH },
                        height: { ideal: CANVAS_HEIGHT }
                    },
                });
                videoElement.srcObject = stream;
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = resolve;
                });

                // Start the MediaPipe video processing
                videoElement.play();
                isCameraActive = true;
                statusMessage.textContent = "Camera active. Adjusting for start screen...";
                
                // Set canvas size to match video
                canvasElement.width = CANVAS_WIDTH;
                canvasElement.height = CANVAS_HEIGHT;

                // Start the continuous drawing loop
                drawGame(); 
                
                // Start MediaPipe processing on the video stream
                sendToMediaPipe();
                
                // Attach start button functionality only after camera is ready
                // Note: The button's onclick is now set in the DOMContentLoaded block
            } catch (err) {
                statusMessage.textContent = `Camera Error: ${err.name}. Please ensure camera access is granted.`;
                console.error("Camera access denied or device error:", err);
            }
        }

        async function sendToMediaPipe() {
            if (!isCameraActive) return;

            // MediaPipe requires the video stream to be constantly fed to it
            await hands.send({ image: videoElement });
            
            // Schedule the next frame processing immediately
            requestAnimationFrame(sendToMediaPipe);
        }

        // --- Entry Point ---
        
        document.addEventListener('DOMContentLoaded', () => {
            statusMessage.textContent = "Checking library readiness...";
            startButton.onclick = startGame; // Set button handler

            // Check for MediaPipe and Matter.js readiness
            if (typeof Hands !== 'undefined' && typeof Matter !== 'undefined') {
                statusMessage.textContent = "Libraries loaded. Starting camera...";
                // This line triggers the camera permission pop-up immediately
                startCamera();
            } else {
                // Set a short delay to allow async script loading to complete
                setTimeout(() => {
                    if (typeof Hands !== 'undefined' && typeof Matter !== 'undefined') {
                        statusMessage.textContent = "Libraries loaded after delay. Starting camera...";
                        startCamera();
                    } else {
                        statusMessage.textContent = "Fatal Error: External libraries failed to load.";
                    }
                }, 100); 
            }
        });
    </script>
</body>
</html>
