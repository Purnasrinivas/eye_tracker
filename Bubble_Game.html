<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Bubble Pop Game (Web)</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load MediaPipe Hands for gesture tracking -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <!-- Load Matter.js for physics simulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* Ensure the body takes full viewport height for centering */
        body {
            height: 100vh;
            background-color: #1a202c; /* Dark background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', sans-serif;
        }
        /* Style the canvas to ensure it is visible and centered */
        #game-canvas {
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            /* Remove background-color here so the video drawn underneath is visible */
            background-color: transparent; 
        }
    </style>
</head>
<body class="p-4">

    <div class="max-w-4xl w-full text-white text-center">
        <h1 class="text-4xl font-extrabold mb-2 text-teal-400">Gesture Bubble Pop (Web)</h1>
        <p class="text-sm mb-6 text-gray-400" id="status-message">
            Loading MediaPipe and Physics Engine...
        </p>

        <!-- Display Score and Instructions -->
        <div class="flex justify-between items-center mb-4 p-3 bg-gray-700 rounded-lg shadow-lg">
            <div id="score-display" class="text-3xl font-bold text-yellow-300">Score: 0</div>
            <!-- NEW MISSED COUNT DISPLAY -->
            <div id="missed-display" class="text-2xl font-semibold text-red-400">Missed: 0 / 3</div>
            <div class="text-left text-sm text-gray-300">
                <p>ðŸ‘Š **POP:** Closed fist + Index finger near bubble.</p>
                <p>âœ‹ **PUSH:** Open palm to move bubbles.</p>
            </div>
        </div>
        
        <!-- Video element for camera feed (hidden from display, but stream is accessible) -->
        <video id="webcam" autoplay playsinline style="display: none;"></video>
        
        <!-- Canvas for rendering the game overlay -->
        <canvas id="game-canvas" width="1024" height="576"></canvas>
    </div>

    <script>
        // --- Global Config ---
        const CANVAS_WIDTH = 1024;
        const CANVAS_HEIGHT = 576;
        const SPAWN_INTERVAL = 1500; // ms
        const BUBBLE_RADIUS_MIN = 20;
        const BUBBLE_RADIUS_MAX = 40;
        const POP_DISTANCE_THRESHOLD = 30; // Max distance in pixels to pop

        // --- Game State ---
        let score = 0;
        let bubbles = [];
        let lastSpawnTime = Date.now();
        let handLandmarks = null;
        let isCameraActive = false;
        
        // NEW GAME OVER STATE
        let missedBubblesCount = 0;
        const maxMissedBubbles = 3;
        let isGameOver = false;
        let spawnIntervalId = null;

        // --- DOM Elements ---
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('game-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const statusMessage = document.getElementById('status-message');
        const missedDisplay = document.getElementById('missed-display'); // New DOM element

        // --- Physics Engine (Matter.js) Setup ---
        const Engine = Matter.Engine,
              Events = Matter.Events, // Import Events
              Render = Matter.Render, 
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Vector = Matter.Vector;

        const engine = Engine.create();
        const world = engine.world;
        // Set gravity to negative so bubbles float upwards toward the miss zone (top)
        engine.gravity.y = -0.05; 
        
        // Add boundaries (Ground and Walls)
        const thickness = 30; 
        
        // Define bodies outside the array for access in event listeners
        const floor = Bodies.rectangle(CANVAS_WIDTH / 2, CANVAS_HEIGHT - thickness / 2, CANVAS_WIDTH, thickness, { 
            isStatic: true, 
            label: 'Floor', 
            id: 'floor', // Add unique ID for collision detection
            render: { fillStyle: '#4a5568' } // Gray floor boundary
        });
        const ceiling = Bodies.rectangle(CANVAS_WIDTH / 2, thickness / 2, CANVAS_WIDTH, thickness, { 
            isStatic: true, 
            label: 'Ceiling', 
            id: 'ceiling', // Add unique ID for collision detection
            render: { fillStyle: '#ff0000' } // Red miss zone
        });
        
        const walls = [
            floor,
            ceiling,
            // Walls
            Bodies.rectangle(thickness / 2, CANVAS_HEIGHT / 2, thickness, CANVAS_HEIGHT, { isStatic: true, label: 'Wall' }),
            Bodies.rectangle(CANVAS_WIDTH - thickness / 2, CANVAS_HEIGHT / 2, thickness, CANVAS_HEIGHT, { isStatic: true, label: 'Wall' }),
        ];
        Composite.add(world, walls);
        
        // --- Matter.js Collision Handling ---
        Events.on(engine, 'collisionStart', (event) => {
            if (isGameOver) return;

            const pairs = event.pairs;
            
            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                let bubbleBody = null;
                // We only care about the floor boundary collision
                if (bodyA.label === 'Bubble' && bodyB.id === 'ceiling') {
                    bubbleBody = bodyA;
                } else if (bodyB.label === 'Bubble' && bodyA.id === 'ceiling') {
                    bubbleBody = bodyB;
                }

                // If a bubble hits the ceiling/miss zone, count it as a miss and pop it
                if (bubbleBody) {
                    missedBubblesCount++;
                    missedDisplay.textContent = `Missed: ${missedBubblesCount} / ${maxMissedBubbles}`;
                    removeBubble(bubbleBody); // Remove it immediately to prevent stacking

                    if (missedBubblesCount >= maxMissedBubbles) {
                        gameOver();
                    }
                }
            });
        });


        // --- MediaPipe Hands Setup ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        function onResults(results) {
            // Store normalized landmarks globally
            handLandmarks = results.multiHandLandmarks;
        }
        
        function gameOver() {
            isGameOver = true;
            clearInterval(spawnIntervalId);
            statusMessage.textContent = "GAME OVER! Three bubbles missed. Refresh the page to Retry.";
            
            // Draw game over text immediately
            canvasCtx.font = "bold 60px Inter";
            canvasCtx.fillStyle = 'rgba(255, 50, 50, 0.9)';
            canvasCtx.textAlign = 'center';
            canvasCtx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            canvasCtx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 70);
        }

        // --- Game Logic ---

        function createBubble() {
            const radius = Math.random() * (BUBBLE_RADIUS_MAX - BUBBLE_RADIUS_MIN) + BUBBLE_RADIUS_MIN;
            // Spawn point at the bottom of the screen (high Y in Matter.js world)
            const x = CANVAS_WIDTH * (0.2 + Math.random() * 0.6);
            const y = CANVAS_HEIGHT - radius - 5; 
            
            const bubble = Bodies.circle(x, y, radius, {
                restitution: 0.9,
                friction: 0.001,
                density: 0.0001, 
                label: 'Bubble',
                plugin: { 
                    bubble: true, 
                    radius: radius 
                }
            });

            Composite.add(world, bubble);
            bubbles.push(bubble);
        }

        function removeBubble(bubble) {
            Composite.remove(world, bubble);
            bubbles = bubbles.filter(b => b.id !== bubble.id);
        }

        function popBubbleCheck(handLandmarks) {
            if (!handLandmarks) return;

            handLandmarks.forEach(landmarks => {
                // MediaPipe gives normalized (0 to 1) coordinates.
                if (!landmarks) return;

                // --- MIRRORING FIX: Apply 1 - X transformation ---
                const standardTipX = landmarks[8].x;
                const tipX = CANVAS_WIDTH * (1 - standardTipX); // Mirrored X
                const tipY = landmarks[8].y * CANVAS_HEIGHT;

                // Check for POP Gesture: Index Tip (8) is *above* Index MCP (5)
                const isPopGesture = landmarks[8].y < landmarks[5].y;

                // Check for Closed Fist: Middle finger tip (12) is below middle finger MCP (9)
                const isClosed = landmarks[12].y > landmarks[9].y && landmarks[16].y > landmarks[13].y;
                
                if (isPopGesture && isClosed) {
                    // Draw Red Circle for Pop Gesture
                    canvasCtx.beginPath();
                    canvasCtx.arc(tipX, tipY, 15, 0, 2 * Math.PI);
                    canvasCtx.strokeStyle = 'red';
                    canvasCtx.lineWidth = 3;
                    canvasCtx.stroke();

                    // Check for bubble contact
                    bubbles.forEach(bubble => {
                        // Matter.js Y is inverted for drawing (Y=0 is top in physics, Y=0 is top in canvas)
                        const bubbleX = bubble.position.x;
                        const bubbleY = CANVAS_HEIGHT - bubble.position.y;
                        const radius = bubble.plugin.radius;

                        const distance = Math.hypot(tipX - bubbleX, tipY - bubbleY);

                        if (distance < radius + POP_DISTANCE_THRESHOLD) {
                            score++;
                            scoreDisplay.textContent = `Score: ${score}`;
                            removeBubble(bubble);
                        }
                    });
                } 
                
                // --- Gesture: PUSH/MOVE (Open Palm) ---
                else if (landmarks[12].y < landmarks[9].y) { // Simple check for open hand
                    // --- MIRRORING FIX: Apply 1 - X transformation ---
                    const standardPalmX = landmarks[0].x;
                    const palmX = CANVAS_WIDTH * (1 - standardPalmX); // Mirrored X
                    const palmY = landmarks[0].y * CANVAS_HEIGHT;

                    // Draw Yellow Circle for Push Gesture
                    canvasCtx.beginPath();
                    canvasCtx.arc(palmX, palmY, 20, 0, 2 * Math.PI);
                    canvasCtx.strokeStyle = 'yellow';
                    canvasCtx.lineWidth = 3;
                    canvasCtx.stroke();

                    // Apply force to bubbles near the palm
                    bubbles.forEach(bubble => {
                        const bubblePos = { x: bubble.position.x, y: CANVAS_HEIGHT - bubble.position.y };
                        const palmPos = { x: palmX, y: palmY };
                        const radius = bubble.plugin.radius;

                        const distance = Math.hypot(palmPos.x - bubblePos.x, palmPos.y - bubblePos.y);

                        if (distance < radius + 50) {
                            // Calculate simple push force away from the palm
                            const dx = bubblePos.x - palmPos.x;
                            const dy = bubblePos.y - palmPos.y;
                            
                            // Matter.js force vector must be in the physics coordinate system (Y inverted)
                            const force = Vector.mult({ x: dx, y: -dy }, 0.00005); 
                            Matter.Body.applyForce(bubble, bubble.position, force);
                        }
                    });
                }
            });
        }

        // --- Rendering Loop ---

        function drawGame() {
            
            // NEW: Check Game Over State
            if (isGameOver) {
                gameOver(); // Redraws the Game Over screen
                return;
            }
            
            // 1. Draw the live video feed as the background (Mirrored for user experience)
            canvasCtx.save();
            canvasCtx.scale(-1, 1);
            // Translate origin to the right side of the canvas before drawing the flipped image
            canvasCtx.translate(-CANVAS_WIDTH, 0); 
            canvasCtx.drawImage(videoElement, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            canvasCtx.restore(); // Restore context state

            // 2. Draw Bubbles
            canvasCtx.fillStyle = 'rgba(100, 255, 255, 0.5)'; // Light blue translucent
            canvasCtx.strokeStyle = 'rgba(100, 255, 255, 1)';
            canvasCtx.lineWidth = 2;
            
            // Iterate backwards to safely remove elements
            // We no longer check for missed bubbles here, as collision events handle it
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const bubble = bubbles[i];
                const x = bubble.position.x;
                // Convert Matter.js Y (bottom-up) to Canvas Y (top-down)
                const y = CANVAS_HEIGHT - bubble.position.y; 
                const radius = bubble.plugin.radius;

                canvasCtx.beginPath();
                canvasCtx.arc(x, y, radius, 0, 2 * Math.PI);
                canvasCtx.fill();
                canvasCtx.stroke();
            }
            
            // 3. Draw Hand Gestures and Check for Pops
            popBubbleCheck(handLandmarks);

            // Draw boundaries 
            
            // Draw the ground/floor zone (bottom) in GRAY
            canvasCtx.fillStyle = '#4a5568';
            canvasCtx.fillRect(0, CANVAS_HEIGHT - thickness, CANVAS_WIDTH, thickness);

            // Draw the ceiling/miss zone (top) in RED 
            canvasCtx.fillStyle = 'rgba(255, 0, 0, 0.5)'; 
            canvasCtx.fillRect(0, 0, CANVAS_WIDTH, thickness); 

            // 4. Update Physics Engine
            Engine.update(engine, 1000 / 60); 

            // 5. Request next frame
            requestAnimationFrame(drawGame);
        }

        // --- Initialization and Camera ---

        async function startCamera() {
            statusMessage.textContent = "Requesting camera permission...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    'video': {
                        facingMode: 'user',
                        width: { ideal: CANVAS_WIDTH },
                        height: { ideal: CANVAS_HEIGHT }
                    },
                });
                videoElement.srcObject = stream;
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = resolve;
                });

                // Start the MediaPipe video processing
                videoElement.play();
                isCameraActive = true;
                statusMessage.textContent = "Camera active. Running gesture detection...";
                
                // Set canvas size to match video
                canvasElement.width = CANVAS_WIDTH;
                canvasElement.height = CANVAS_HEIGHT;

                // Start physics and game loops
                spawnIntervalId = setInterval(createBubble, SPAWN_INTERVAL); // Store interval ID
                drawGame(); // Starts the continuous drawing loop
                
                // Start MediaPipe processing on the video stream
                sendToMediaPipe();

            } catch (err) {
                statusMessage.textContent = `Camera Error: ${err.name}. Please ensure camera access is granted.`;
                console.error("Camera access denied or device error:", err);
            }
        }

        async function sendToMediaPipe() {
            if (!isCameraActive) return;

            // MediaPipe requires the video stream to be constantly fed to it
            await hands.send({ image: videoElement });
            
            // Schedule the next frame processing immediately
            requestAnimationFrame(sendToMediaPipe);
        }

        // --- Entry Point ---
        
        // This streamlined entry point requests camera access immediately.
        document.addEventListener('DOMContentLoaded', () => {
            statusMessage.textContent = "Checking library readiness...";
            
            // Check for MediaPipe and Matter.js readiness
            if (typeof Hands !== 'undefined' && typeof Matter !== 'undefined') {
                statusMessage.textContent = "Libraries loaded. Starting camera...";
                // This line triggers the camera permission pop-up immediately
                startCamera();
            } else {
                // Set a short delay to allow async script loading to complete
                setTimeout(() => {
                    if (typeof Hands !== 'undefined' && typeof Matter !== 'undefined') {
                        statusMessage.textContent = "Libraries loaded after delay. Starting camera...";
                        startCamera();
                    } else {
                        statusMessage.textContent = "Fatal Error: External libraries failed to load.";
                    }
                }, 100); 
            }
        });
    </script>
</body>
</html>
